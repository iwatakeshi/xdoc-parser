lexer grammar XDocSyntaxLexer;

/* Literals (borrowed from Java.g4 and slightly modified) */
// §3.10.1 Integer Literals

NumberLiteral
  : IntegerLiteral
  | FloatingPointLiteral
  ;

IntegerLiteral
	:	DecimalIntegerLiteral
	|	HexIntegerLiteral
	|	OctalIntegerLiteral
	|	BinaryIntegerLiteral
	;

fragment
DecimalIntegerLiteral
	:	DecimalNumeral IntegerTypeSuffix?
	;

fragment
HexIntegerLiteral
	:	HexNumeral IntegerTypeSuffix?
	;

fragment
OctalIntegerLiteral
	:	OctalNumeral IntegerTypeSuffix?
	;

fragment
BinaryIntegerLiteral
	:	BinaryNumeral IntegerTypeSuffix?
	;

fragment
IntegerTypeSuffix
	:	[lL]
	;

fragment
DecimalNumeral
	:	'0'
	|	NonZeroDigit (Digits? | Underscores Digits)
	;

fragment
Digits
	:	Digit (DigitsAndUnderscores? Digit)?
	;

fragment
Digit
	:	'0'
	|	NonZeroDigit
	;

fragment
NonZeroDigit
	:	[1-9]
	;

fragment
DigitsAndUnderscores
	:	DigitOrUnderscore+
	;

fragment
DigitOrUnderscore
	:	Digit
	|	'_'
	;

fragment
Underscores
	:	'_'+
	;

fragment
HexNumeral
	:	'0' [xX] HexDigits
	;

fragment
HexDigits
	:	HexDigit (HexDigitsAndUnderscores? HexDigit)?
	;

fragment
HexDigit
	:	[0-9a-fA-F]
	;

fragment
HexDigitsAndUnderscores
	:	HexDigitOrUnderscore+
	;

fragment
HexDigitOrUnderscore
	:	HexDigit
	|	'_'
	;

fragment
OctalNumeral
	:	'0' [oO] OctalDigits
	;

fragment
OctalDigits
	:	OctalDigit (OctalDigitsAndUnderscores? OctalDigit)?
	;

fragment
OctalDigit
	:	[0-7]
	;

fragment
OctalDigitsAndUnderscores
	:	OctalDigitOrUnderscore+
	;

fragment
OctalDigitOrUnderscore
	:	OctalDigit
	|	'_'
	;

fragment
BinaryNumeral
	:	'0' [bB] BinaryDigits
	;

fragment
BinaryDigits
	:	BinaryDigit (BinaryDigitsAndUnderscores? BinaryDigit)?
	;

fragment
BinaryDigit
	:	[01]
	;

fragment
BinaryDigitsAndUnderscores
	:	BinaryDigitOrUnderscore+
	;

fragment
BinaryDigitOrUnderscore
	:	BinaryDigit
	|	'_'
;

// §3.10.2 Floating-Point Literals

FloatingPointLiteral
	:	DecimalFloatingPointLiteral
	|	HexadecimalFloatingPointLiteral
	;

fragment
DecimalFloatingPointLiteral
	:	Digits '.' Digits? ExponentPart? FloatTypeSuffix?
	|	'.' Digits ExponentPart? FloatTypeSuffix?
	|	Digits ExponentPart FloatTypeSuffix?
	|	Digits FloatTypeSuffix
	;

fragment
ExponentPart
	:	ExponentIndicator SignedInteger
	;

fragment
ExponentIndicator
	:	[eE]
	;

fragment
SignedInteger
	:	Sign? Digits
	;

fragment
Sign
	:	[+-]
	;

fragment
FloatTypeSuffix
	:	[fFdD]
	;

fragment
HexadecimalFloatingPointLiteral
	:	HexSignificand BinaryExponent FloatTypeSuffix?
	;

fragment
HexSignificand
	:	HexNumeral '.'?
	|	'0' [xX] HexDigits? '.' HexDigits
	;

fragment
BinaryExponent
	:	BinaryExponentIndicator SignedInteger
	;

fragment
BinaryExponentIndicator
	:	[pP]
	;

// §3.10.3 Boolean Literals

BooleanLiteral
	:	'true'
	|	'false'
	;

// §3.10.4 Character Literals

CharacterLiteral
	:	'\'' SingleCharacter '\''
	|	'\'' EscapeSequence '\''
	;

fragment
SingleCharacter
	:	~['\\\r\n]
	;
// §3.10.5 String Literals
StringLiteral
	:	'"' StringCharacters? '"'
	| '\'' StringCharacters? '\''
	;
fragment
StringCharacters
	:	StringCharacter+
	;
fragment
StringCharacter
	:	~["\\\r\n]
	|	EscapeSequence
	;
// §3.10.6 Escape Sequences for Character and String Literals
fragment
EscapeSequence
	:	'\\' [btnfr"'\\]
	|	OctalEscape
    |   UnicodeEscape // This is not in the spec but prevents having to preprocess the input
	;

fragment
OctalEscape
	:	'\\' OctalDigit
	|	'\\' OctalDigit OctalDigit
	|	'\\' ZeroToThree OctalDigit OctalDigit
	;

fragment
ZeroToThree
	:	[0-3]
	;

// This is not in the spec but prevents having to preprocess the input
fragment
UnicodeEscape
    :   '\\' 'u'+ HexDigit HexDigit HexDigit HexDigit
    ;

// §3.10.7 The Null Literal

NullLiteral
	:	'null'
	| 'undefined'
;

/* Tom Tokens */

EXTENDS
	: 'extends'
	;

ID
  : /* Prevent the lexer from identifying certain tokens as ID*/
	{
    if (this.text == "true" || this.text == "false") this.type = XDocSyntaxLexer.BooleanLiteral;
    if (this.text == "null" || this.text == "undefined") this.type = XDocSyntaxLexer.NullLiteral;
		if (this.text == "extends") this.type = XDocSyntaxLexer.EXTENDS;

  } LETTER (LETTER | DIGIT)*
	;

NEWLINE
	: '\n' SPACE?
	| '\r\n' SPACE?
	| '\r' SPACE?
	;

SPACE
	: (' '|'\t')+
	;

TEXT_CONTENT
	: ~[<>'|&0123456789".,\n\r\t +=@*{}()[\]/:?!-]+
	;

AT
	: '@'
	;

PLUS
  : '+'
  ;

MINUS
    : '-'
    ;

STAR
    : '*'
    ;


FORWARD_SLASH
    : '/'
    ;

COLON
    : ':'
    ;

PERIOD
    : '.'
    ;

COMMA
  : ','
  ;

EQUAL
  : '='
  ;

QUESTION
  : '?'
  ;

AMP
  : '&'
  ;

PIPE
  : '|'
  ;

ARROW
  : EQUAL GREATERTHAN
  | MINUS GREATERTHAN
  ;

EXCLAMATION
  : '!'
  ;

INLINE_TAG_START
	: '{@'
	;


BRACE_OPEN
    : '{'
    ;

BRACE_CLOSE
    : '}'
    ;

PAREN_OPEN
  : '('
  ;

PAREN_CLOSE
  : ')'
  ;

BRACKET_OPEN
  : '['
  ;

BRACKET_CLOSE
  : ']'
  ;

LESSTHAN
  : '<'
  ;

GREATERTHAN
  : '>'
  ;

fragment
LETTER: [a-zA-Z];

fragment
DIGIT: [0-9];
